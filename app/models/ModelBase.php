<?php
/**
 * Created by PhpStorm.
 * User: helenpham
 * Date: 11/7/14
 * Time: 11:18
 */

class ModelBase extends DBAccess{

    const CALL_ACTION_INSERT='INSERT';
    const CALL_ACTION_UPDATE='UPDATE';

    protected  $cache_object_ids=array();
    protected  $memory_caches=array();

    public function __construct($name)
    {
        parent::__construct($name); // TODO: Change the autogenerated stub
    }

    public function getOneObjectByField($field) {
        $objects=$this->getObjectsByField($field);
        if(count($objects)>0) {
            return $objects[0];
        } else {
            return null;
        }
    }

    /**
     * @param $fields : the array of field name and value
     * @throws Exception : throw exception if this method is not implement by child class
     * @return : array of Objects
     */
    public  function  getObjectsByField($fields)
    {
        if(array_key_exists('id',$fields)) {
            if($this->existCache($fields['id'])) {
                return array($this->getFromCache($fields['id']));
            }
        }
        $query=array();

        foreach ($fields as $key => $value) {
            $query[]=$key."='".$value."'";
        }

        if(count($query)==0) {
            $sql="select * from {$this->table_name}";
        } else {
            $sql="select * from {$this->table_name} where ".implode(" and ",$query);
        }

        $result=DBConnection::read()->select($sql);
        if(count($result)>0) {
            foreach ($result as $item) {
                // add to cache
                $this->addToCache($item->id,$item,ModelBase::CALL_ACTION_UPDATE);
            }
            return $result;
        } else {
            return array();
        }
    }

    /**
     * @param $fields : array of field names and value
     * @return : array of objects
     * @throws Exception : throw exception if this function has not yet implemented by child class
     */
    public function getObjectsByFields($fields)
    {
        if(!is_array($fields)) {
            throw new Exception("Invalid input in getObjectsByFields from {$this->table_name} object");
        }
        $query=array();
        foreach ($fields as $field =>$value) {
            if(!is_array($value)) {$value=array($value);}
            $query[]=$field." in ('".implode("','",$value)."') ";
        }

        $sql="select * from {$this->table_name} where ".implode(" and ",$query);

        $result=DBConnection::read()->select($sql);

        foreach ($result as $item) {

            $this->addToCache($item->id,$item,ModelBase::CALL_ACTION_UPDATE);
        }
        return $result;
    }

    /**
     * @param $objects : the complex object need to analytic and get reference objects
     * @throws Exception : throw exception if child class do not implemented this function
     */
    protected function analyticCacheIds($object) {
        throw new Exception("analyticReferenceObjects function from {$this->table_name} has not yet implemented");
    }

    public function generateCacheObjects() {
        throw new Exception("generateCacheObjects function from {$this->table_name} has not yet implemented");
    }


    public function addCacheObjectId($id) {
        if(isset($id) && $id!='' && $id!=-1) {
            if(!in_array($id,$this->cache_object_ids)) {
                $this->cache_object_ids[]=$id;
            }
        }
    }

    public function addToCache($key,$object,$action=null) {
        if($action!=null) {
            //call back to update info cache
            $this->addToCacheCallBack($object,$action);
        }
        CacheAccessor::getInstance()->set($this->table_name,$key,$object);

    }

    private function addToCacheCallBack($object,$action) {
        if($action==ModelBase::CALL_ACTION_INSERT) {
            $this->insertToInfoCache($object);
        } elseif($action==ModelBase::CALL_ACTION_UPDATE) {
            $this->updateToInfoCache($object);
        }
    }
    protected function insertToInfoCache($object) {
        return;
    }
    protected function updateToInfoCache($object) {
        return;
    }

    public function getFromCache($key)
    {
        // get from redis cache
        return CacheAccessor::getInstance()->get($this->table_name,$key);
    }

    /**
     * @return : array of reference ids
     */
    public function getCacheObjectIds()
    {
        return $this->cache_object_ids;
    }

    public function setCacheObjectIds($ids) {
        $this->cache_object_ids=$ids;
    }

    public function existCache($key) {
        return CacheAccessor::getInstance()->exists($this->table_name,$key);
    }

    public function getParamValue($name,$param=array(),$default=null)
    {
        if ($name == 'created_at' || $name == 'updated_at' || $name == 'last_login') {
            return time(); // UTC time
        } elseif (array_key_exists($name, $param)) {
            return $param[$name];
        } else {
            return $default;
        }
    }
    public function updateCacheById($id_array,$values)
    {
        $cacheInstance=CacheAccessor::getInstance();
        $id_key=array_keys($id_array)[0];
        $id_value=array_values($id_array)[0];
        if($cacheInstance->exists($this->table_name,$id_value)) {
            // exist on cache ==> get from cache and save again
            $object=$cacheInstance->get($this->table_name,$id_value);
            $obj_array=(array)$object;
            foreach ($values as $key => $value) {
                $obj_array[$key]=$value;

                if(is_array($value)) {
                    $first_val=array_shift($value);
                    if($first_val=='now()') {
                        $obj_array[$key]=time();
                    }
                }
            }

            $this->addToCache($id_value,(object)$obj_array,ModelBase::CALL_ACTION_UPDATE);

        } else {
            // elect from database and insert to cache
            $sql="select * from {$this->table_name} where {$id_key}=?";
            $result=DBConnection::read()->select($sql,array($id_value));

            if(count($result)>0) {
                $obj_array=(array)$result[0];
                foreach ($result[0] as $key => $value) {
                    if($key=='created_at'|| $key=='updated_at' || $key=='sort_time' || $key=='last_action' || $key=='last_login') {
                        $obj_array[$key]=strtotime($value);
                    } else {
                        $obj_array[$key]=$value;
                    }
                }

                $this->addToCache($id_value,(object)$obj_array,ModelBase::CALL_ACTION_UPDATE);
            }
        }
    }
    protected  function createCacheObject($id,$params)
    {
        throw new APIException("Method createCacheObject from {$this->table_name} have not implemented");
    }

    public function insert($param)
    {
        $id= parent::insert($param);
        $new_movie=$this->createCacheObject($id,$param);
        $this->addToCache($new_movie->id,$new_movie,ModelBase::CALL_ACTION_INSERT);
    }

    public function update($set_Params, $where)
    {
        $where= parent::update($set_Params, $where); // TODO: Change the autogenerated stub
        if(array_key_exists('id',$where)) {
            $this->updateCacheById(array('id'=>$where['id']),$set_Params);
        } else {
            $this->getOneObjectByField($where);
        }
    }

    public function inserts($fields = array(), $fieldValues = array())
    {
        $ids= parent::inserts($fields, $fieldValues); // TODO: Change the autogenerated stub
        foreach ($ids as $id) {
            $new_object=$this->createCacheObject($id,$fieldValues);
            $this->addToCache($id,$new_object,ModelBase::CALL_ACTION_INSERT);
        }
    }
}